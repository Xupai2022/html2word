"""
Table builder for Word documents.

Builds Word tables from HTML table elements with proper cell merging.
"""

import logging
from typing import List, Optional, Tuple, Dict
from docx.shared import Inches

from html2word.parser.dom_tree import DOMNode
from html2word.word_builder.style_mapper import StyleMapper
from html2word.word_builder.paragraph_builder import ParagraphBuilder

logger = logging.getLogger(__name__)


class TableBuilder:
    """Builds Word tables from HTML table nodes."""

    def __init__(self, document):
        """
        Initialize table builder.

        Args:
            document: python-docx Document object
        """
        self.document = document
        self.style_mapper = StyleMapper()
        self.paragraph_builder = ParagraphBuilder(document)

    def build_table(self, table_node: DOMNode) -> Optional[object]:
        """
        Build a Word table from HTML table node.

        Args:
            table_node: Table DOM node

        Returns:
            python-docx Table object or None
        """
        if table_node.tag != 'table':
            return None

        # Extract table structure
        rows = self._extract_rows(table_node)
        if not rows:
            return None

        # Calculate dimensions
        num_rows = len(rows)
        num_cols = self._calculate_columns(rows)

        if num_rows == 0 or num_cols == 0:
            return None

        # Create table
        table = self.document.add_table(rows=num_rows, cols=num_cols)

        # Fill table cells
        self._fill_table(table, rows)

        # Apply table-level styles
        self._apply_table_style(table, table_node)

        return table

    def _extract_rows(self, table_node: DOMNode) -> List[DOMNode]:
        """
        Extract row nodes from table.

        Args:
            table_node: Table DOM node

        Returns:
            List of row nodes (tr)
        """
        rows = []

        # Process children to find rows
        for child in table_node.children:
            if child.tag == 'tr':
                rows.append(child)
            elif child.tag in ('thead', 'tbody', 'tfoot'):
                # Process section
                for section_child in child.children:
                    if section_child.tag == 'tr':
                        rows.append(section_child)

        return rows

    def _calculate_columns(self, rows: List[DOMNode]) -> int:
        """
        Calculate number of columns in table.

        Args:
            rows: List of row nodes

        Returns:
            Number of columns
        """
        max_cols = 0

        for row in rows:
            col_count = 0
            for cell in row.children:
                if cell.tag in ('td', 'th'):
                    colspan = int(cell.get_attribute('colspan', '1'))
                    col_count += colspan
            max_cols = max(max_cols, col_count)

        return max_cols

    def _fill_table(self, table, rows: List[DOMNode]):
        """
        Fill table with content and handle cell merging.

        Args:
            table: python-docx Table object
            rows: List of row nodes
        """
        # Build cell matrix to track merged cells
        matrix = self._build_cell_matrix(rows)

        # Fill cells
        for row_idx, row_node in enumerate(rows):
            word_row = table.rows[row_idx]
            col_idx = 0

            for cell_node in row_node.children:
                if cell_node.tag not in ('td', 'th'):
                    continue

                # Skip cells that are part of a previous merge
                while col_idx < len(matrix[row_idx]) and matrix[row_idx][col_idx] is None:
                    col_idx += 1

                if col_idx >= len(word_row.cells):
                    break

                word_cell = word_row.cells[col_idx]

                # Get colspan and rowspan
                colspan = int(cell_node.get_attribute('colspan', '1'))
                rowspan = int(cell_node.get_attribute('rowspan', '1'))

                # Handle cell merging
                if colspan > 1 or rowspan > 1:
                    self._merge_cells(table, row_idx, col_idx, rowspan, colspan)

                # Fill cell content
                self._fill_cell(word_cell, cell_node)

                # Apply cell styles
                box_model = cell_node.layout_info.get('box_model')
                self.style_mapper.apply_table_cell_style(
                    word_cell,
                    cell_node.computed_styles,
                    box_model
                )

                col_idx += colspan

    def _build_cell_matrix(self, rows: List[DOMNode]) -> List[List[Optional[DOMNode]]]:
        """
        Build matrix to track cell positions including merged cells.

        Args:
            rows: List of row nodes

        Returns:
            Matrix where None indicates a merged cell
        """
        if not rows:
            return []

        num_rows = len(rows)
        num_cols = self._calculate_columns(rows)
        matrix = [[None for _ in range(num_cols)] for _ in range(num_rows)]

        for row_idx, row_node in enumerate(rows):
            col_idx = 0

            for cell_node in row_node.children:
                if cell_node.tag not in ('td', 'th'):
                    continue

                # Find next available column
                while col_idx < num_cols and matrix[row_idx][col_idx] is not None:
                    col_idx += 1

                if col_idx >= num_cols:
                    break

                # Get span values
                colspan = int(cell_node.get_attribute('colspan', '1'))
                rowspan = int(cell_node.get_attribute('rowspan', '1'))

                # Mark cells as occupied
                for r in range(row_idx, min(row_idx + rowspan, num_rows)):
                    for c in range(col_idx, min(col_idx + colspan, num_cols)):
                        matrix[r][c] = cell_node

                col_idx += colspan

        return matrix

    def _merge_cells(self, table, row_idx: int, col_idx: int, rowspan: int, colspan: int):
        """
        Merge table cells.

        Args:
            table: python-docx Table object
            row_idx: Starting row index
            col_idx: Starting column index
            rowspan: Number of rows to span
            colspan: Number of columns to span
        """
        try:
            # Get starting cell
            start_cell = table.rows[row_idx].cells[col_idx]

            # Get ending cell
            end_row_idx = min(row_idx + rowspan - 1, len(table.rows) - 1)
            end_col_idx = min(col_idx + colspan - 1, len(table.rows[0].cells) - 1)
            end_cell = table.rows[end_row_idx].cells[end_col_idx]

            # Merge
            if start_cell != end_cell:
                start_cell.merge(end_cell)
        except Exception as e:
            logger.warning(f"Error merging cells: {e}")

    def _fill_cell(self, word_cell, cell_node: DOMNode):
        """
        Fill cell with content.

        Args:
            word_cell: python-docx Cell object
            cell_node: Cell DOM node
        """
        # Clear default paragraph
        if word_cell.paragraphs:
            word_cell.paragraphs[0].clear()

        # Check if cell has any content
        has_content = False

        # Process cell content - handle text and inline elements
        for child in cell_node.children:
            if child.is_text:
                text = child.text or ""
                # Skip pure whitespace text nodes
                if text.strip():
                    # Create paragraph if needed
                    if not has_content:
                        paragraph = word_cell.paragraphs[0] if word_cell.paragraphs else word_cell.add_paragraph()
                        has_content = True
                    else:
                        paragraph = word_cell.add_paragraph()

                    # Add text with cell styles
                    run = paragraph.add_run(text.strip())
                    self.style_mapper.apply_run_style(run, cell_node.computed_styles)

            elif child.is_element:
                # Handle different element types
                if child.tag == 'br':
                    # Line break
                    if has_content:
                        word_cell.add_paragraph()
                elif child.tag in ('p', 'div'):
                    # Block element - create new paragraph
                    paragraph = word_cell.add_paragraph()
                    has_content = True
                    self._add_cell_paragraph_content(paragraph, child)
                else:
                    # Inline element - add to current or new paragraph
                    if not has_content:
                        paragraph = word_cell.paragraphs[0] if word_cell.paragraphs else word_cell.add_paragraph()
                        has_content = True
                    else:
                        # Check if we need a new paragraph or continue current
                        if word_cell.paragraphs:
                            paragraph = word_cell.paragraphs[-1]
                        else:
                            paragraph = word_cell.add_paragraph()

                    self._add_cell_inline_content(paragraph, child)

    def _add_cell_paragraph_content(self, paragraph, node: DOMNode):
        """Add content from a block element to a cell paragraph."""
        # Apply paragraph styles
        box_model = node.layout_info.get('box_model')
        self.style_mapper.apply_paragraph_style(paragraph, node.computed_styles, box_model)

        # Add text and inline children
        for child in node.children:
            if child.is_text:
                text = child.text or ""
                if text.strip():
                    run = paragraph.add_run(text.strip())
                    self.style_mapper.apply_run_style(run, node.computed_styles)
            elif child.is_inline:
                self._add_cell_inline_content(paragraph, child)

    def _add_cell_inline_content(self, paragraph, node: DOMNode):
        """Add inline element content to paragraph."""
        for child in node.children:
            if child.is_text:
                text = child.text or ""
                if text.strip():
                    run = paragraph.add_run(text.strip())
                    # Use the inline element's computed styles
                    self.style_mapper.apply_run_style(run, node.computed_styles)
            elif child.is_inline:
                # Nested inline element
                self._add_cell_inline_content(paragraph, child)

    def _apply_table_style(self, table, table_node: DOMNode):
        """
        Apply table-level styles.

        Args:
            table: python-docx Table object
            table_node: Table DOM node
        """
        # Set table width if specified
        box_model = table_node.layout_info.get('box_model')
        if box_model and box_model.width:
            try:
                table.width = Inches(box_model.width / 72)  # pt to inches
            except:
                pass

        # Apply table style
        try:
            table.style = 'Table Grid'
        except:
            pass
